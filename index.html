<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>DaRT – Blockchain for Science</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="styles.css">
</head>
<body class="nn-stage-0">

  <!-- Full-screen background animation  -->
<div class="nn-bg-animation">
  <!-- Desktop video -->
  <video class="nn-bg-video nn-bg-video-desktop" muted playsinline preload="auto">
    <source src="hero-animation-end-white-intra.mp4" type="video/mp4">
  </video>

    <!-- Mobile canvas animation -->
    <canvas id="nn-mobile-canvas" class="nn-bg-video-mobile"></canvas>

</div>


  <!-- HEADER -->
  <header class="nn-header">
    <div class="nn-container nn-header-inner">
      <a href="#top" class="nn-logo-link">
        <img src="logo-surtin-trans.png" alt="Dart" class="nn-logo">
        <span class="nn-logo-text">DaRT – Blockchain for Science</span>
      </a>      
      <nav class="nn-nav">
        <a href="#about">About</a>
        <a href="#technology">Technology</a>
        <a href="#applications">Applications</a>
        <a href="#contact">Contact</a>
      </nav>
    </div>
  </header>

  <main id="top">
    <!-- HERO PANEL: only one sentence scrolling over the animation -->
    <section class="nn-hero-panel">
      <div class="nn-container nn-hero-sticky">
        <p class="nn-hero-sentence">From experiments to verifiable chains.</p>
      </div>
    </section>

    <!-- AFTER HERO: normal sections on white background -->
    <section id="about" class="nn-section">
      <div class="nn-container nn-grid-2">
        <div>
          <h2>Scientific work provenance</h2>
          <p>
            Most scientific results still live in scattered folders.
            We bind participants, experiments, analyses, and outputs to blockchain entries so anyone
            can see <em>what</em> was done, <em>when</em>, and with <em>which data</em>.
          </p>
          <p>
            Our infrastructure is designed for real labs: messy data, evolving
            protocols, and limited engineering support.
          </p>
        </div>
        <div>
          <h3>Practical guarantees</h3>
          <ul class="nn-list">
            <li>Cryptographic hashes of raw and processed datasets</li>
            <li>Time-stamped on-chain records for key milestones</li>
            <li>Validation of computation assuring figures are legitimate</li>
            <li>Permissioned discovery and sharing for collaborators</li>
          </ul>
        </div>
      </div>
    </section>

    <section id="technology" class="nn-section nn-section-alt">
      <div class="nn-container">
        <header class="nn-section-header">
          <h2>Technology</h2>
          <p>
            The animated scientist is a metaphor: experiments and code flow into a
            test tube, and out comes a cryptographic link that attaches to a larger
            chain of evidence.
          </p>
        </header>

        <div class="nn-card-grid">
          <article class="nn-card">
            <h3>On-chain provenance</h3>
            <p>
              Every registered dataset and algorithm a graph: who did what, when,
              with which inputs. The chain stores hashes and metadata, while
              bulk data stays in your secure storage.
            </p>
          </article>

          <article class="nn-card">
            <h3>Reproducible analysis bundles</h3>
            <p>
              We pin exact versions of analysis images and configurations, so
              downstream users can re-run and confirm figures are indeed representing
              what was originally claimed.
            </p>
          </article>

          <article class="nn-card">
            <h3>Programmable access control</h3>
            <p>
              Smart contracts act as programmable gatekeepers: they govern who
              can discover, request, or compute over your datasets, while you
              keep custodial control.
            </p>
          </article>
        </div>
      </div>
    </section>

    <section id="applications" class="nn-section">
      <div class="nn-container">
        <header class="nn-section-header">
          <h2>Applications</h2>
          <p>
            Built for labs, consortia, and data infrastructures that need more
            than nice figure panels.
          </p>
        </header>

        <div class="nn-app-grid">
          <div class="nn-app-item">
            <h3>Registered analyses</h3>
            <p>
              Lock pre-registered analysis plans and parameter ranges on-chain,
              so deviations and explorations are visible, not hidden.
            </p>
          </div>

          <div class="nn-app-item">
            <h3>Reproducible data releases</h3>
            <p>
              Publish datasets with a formal provenance trail and attach them to
              analysis contracts that anyone can re-run.
            </p>
          </div>

          <div class="nn-app-item">
            <h3>Incentivized replication</h3>
            <p>
              Use tokens or credits to reward robust replications, meta-analyses,
              and stress tests instead of only rewarding novel claims.
            </p>
          </div>
        </div>
      </div>
    </section>

    <section id="contact" class="nn-section nn-contact">
      <div class="nn-container nn-grid-2">
        <div>
          <h2>Contact</h2>
          <p>
            We’re looking for labs, data consortia, and infrastructure teams
            interested in piloting blockchain-backed scientific workflows.
          </p>
          <p class="nn-contact-highlight">
            Tell us about your data, your constraints, and what guarantees you
            wish you had today.
          </p>
        </div>
        <div>
          <form
            class="nn-form"
            name="contact"
            method="POST"
            data-netlify="true"
            netlify-honeypot="bot-field"
            action="/thanks.html"
          >
            <input type="hidden" name="form-name" value="contact">

            <p style="display:none;">
              <label>Don’t fill this out: <input name="bot-field"></label>
            </p>

            <div class="nn-form-row">
              <label for="name">Name</label>
              <input id="name" type="text" name="name" placeholder="Jane Doe" required>
            </div>

            <div class="nn-form-row">
              <label for="email">Email</label>
              <input id="email" type="email" name="email" placeholder="name@example.com" required>
            </div>

            <div class="nn-form-row">
              <label for="message">Message</label>
              <textarea
                id="message"
                name="message"
                rows="4"
                placeholder="Tell us a bit about your use case..."
                required
              ></textarea>
            </div>

            <button type="submit" class="nn-button nn-button-primary">Send message</button>
          </form>
        </div>
      </div>
    </section>
    
  </main>

  <footer class="nn-footer">
    <div class="nn-container nn-footer-inner">
      <p>&copy; 2025 Surtin. All rights reserved.</p>
      <p class="nn-footer-accent">Built for verifiable, reusable science.</p>
    </div>
  </footer>

    <script>
    (function () {
    var body = document.body;

    var isMobile     = window.matchMedia("(max-width: 768px)").matches;
    var desktopVideo = document.querySelector('.nn-bg-video-desktop');
    var hero         = document.querySelector('.nn-hero-panel');

    var stages = 4;

    if (!hero) return;

    // Only use video on desktop
    var video = (!isMobile && desktopVideo) ? desktopVideo : null;

    var heroTop = 0;
    var heroHeight = 1;
    var videoDuration = 1;

    if (video) {
        // Don't actually play; we scrub currentTime manually.
        video.pause();
        video.preload = "auto";

        if (!isNaN(video.duration) && video.duration > 0) {
        videoDuration = video.duration;
        }

        video.addEventListener("loadedmetadata", function () {
        if (video.duration > 0) {
            videoDuration = video.duration;
        }
        });
    }

    function measureHero() {
        var rect = hero.getBoundingClientRect();
        var scrollTop = window.pageYOffset || document.documentElement.scrollTop || 0;
        heroTop = rect.top + scrollTop;
        heroHeight = rect.height || 1;
    }


    function updateStageAndVideo() {
    var scrollTop = window.pageYOffset || document.documentElement.scrollTop || 0;

    var raw = (scrollTop - heroTop) / heroHeight;
    var progress = Math.min(Math.max(raw, 0), 1);

    var idx = Math.min(stages - 1, Math.floor(progress * stages));
    for (var i = 0; i < stages; i++) {
        body.classList.toggle("nn-stage-" + i, i === idx);
    }

    // Use a later threshold on mobile
    var cutoff = isMobile ? 1.1 : 0.9; // tweak 1.0–1.3 as you like
    var afterHero = scrollTop >= heroTop + heroHeight * cutoff;
    body.classList.toggle("nn-after-hero", afterHero);

    if (video) {
        var t = progress * videoDuration;
        if (!isNaN(t)) video.currentTime = t;
    }
    }
    function onResize() {
        measureHero();
        updateStageAndVideo();
    }

    window.addEventListener("scroll", updateStageAndVideo, { passive: true });
    window.addEventListener("resize", onResize);

    measureHero();
    updateStageAndVideo();
    })();
    </script>

    <script>
    (function() {
    const isMobile = window.matchMedia("(max-width: 768px)").matches;
    if (!isMobile) return; // desktop uses video

    const canvas = document.getElementById("nn-mobile-canvas");
    if (!canvas) return;

    const ctx = canvas.getContext("2d");
    const hero = document.querySelector(".nn-hero-panel");
    if (!hero) return;

    const FRAME_COUNT = 60;   // adjust to your actual number
    const frameCache = new Array(FRAME_COUNT);

    let heroTop = 0;
    let heroHeight = 1;
    let lastFrameIndex = 0;

    function resizeCanvas() {
        const w = canvas.clientWidth || window.innerWidth;
        const h = canvas.clientHeight || window.innerHeight;
        const dpr = window.devicePixelRatio || 1;

        canvas.width  = w * dpr;
        canvas.height = h * dpr;

        // Reset transform each time, then scale
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
    }

    function measureHero() {
        const rect = hero.getBoundingClientRect();
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop || 0;
        heroTop = rect.top + scrollTop;
        heroHeight = rect.height || 1;
    }

        function renderFrame(index) {
        const img = frameCache[index];
        if (!img) return;

        const cw = canvas.clientWidth;
        const ch = canvas.clientHeight;
        if (!cw || !ch) return;

        const iw = img.naturalWidth;
        const ih = img.naturalHeight;
        if (!iw || !ih) return;

        // scale to cover canvas (like CSS background-size: cover)
        const scale = Math.max(cw / iw, ch / ih);
        const scaledWidth  = iw * scale;
        const scaledHeight = ih * scale;

        const dx = (cw - scaledWidth) / 2;
        const dy = (ch - scaledHeight) / 2;

        ctx.clearRect(0, 0, cw, ch);
        ctx.drawImage(img, dx, dy, scaledWidth, scaledHeight);
        }


    function onScroll() {
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop || 0;
        const raw = (scrollTop - heroTop) / heroHeight;
        const progress = Math.min(Math.max(raw, 0), 1);
        const frameIndex = Math.floor(progress * (FRAME_COUNT - 1));

        lastFrameIndex = frameIndex;       // remember
        renderFrame(frameIndex);
        }


    function preloadFrames() {
        for (let i = 0; i < FRAME_COUNT; i++) {
        const img = new Image();
        img.src = `frames/frame_${String(i).padStart(3, "0")}.jpg`; // adjust extension/folder if needed

        img.onload = (() => {
            const idx = i;
            return () => {
            frameCache[idx] = img;
            // As soon as frame 0 is ready, draw it once
            if (idx === 0) {
                renderFrame(0);
            }
            };
        })();
        }
    }

    // init
    resizeCanvas();
    measureHero();
    preloadFrames();
    // If frame 0 loads very fast, onload will draw it.
    // If not, you just see beige for a bit, then the first frame pops in.

    window.addEventListener("scroll", onScroll, { passive: true });
    window.addEventListener("resize", () => {
    resizeCanvas();
    measureHero();
    renderFrame(lastFrameIndex); // redraw the last visible frame
    });
    
    })();
    </script>


</body>
</html>
